<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>牌効率チェッカー（ツモ進行＆聴牌練習付き）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #111;
      color: #eee;
    }
    h1 {
      font-size: 1.3rem;
      margin-bottom: 0.5rem;
    }
    .card {
      background: #1b1b1b;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      max-width: 900px;
      margin: 0 auto;
    }
    label {
      font-size: 0.9rem;
    }
    input[type="text"] {
      width: 100%;
      padding: 8px 10px;
      margin-top: 4px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #111;
      color: #eee;
      box-sizing: border-box;
      font-size: 0.95rem;
      font-family: "SF Mono", Menlo, monospace;
    }
    button {
      margin-top: 10px;
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      background: #3b82f6;
      color: white;
      font-size: 0.9rem;
      cursor: pointer;
    }
    button:hover {
      background: #2563eb;
    }
    .checkbox-row {
      margin-top: 8px;
      font-size: 0.9rem;
    }
    .error {
      margin-top: 8px;
      color: #f97373;
      font-size: 0.85rem;
    }
    .result {
      margin-top: 16px;
      font-size: 0.9rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 0.85rem;
    }
    th, td {
      padding: 6px 4px;
      border-bottom: 1px solid #333;
      text-align: left;
      vertical-align: top;
    }
    th {
      border-bottom: 1px solid #555;
      color: #ddd;
    }
    .small-note {
      font-size: 0.8rem;
      color: #aaa;
      margin-top: 4px;
    }
    #countInfo {
      margin-top: 4px;
    }

    /* 牌画像 */
    .tile-img {
      height: 44px;          /* サイズは好みで */
      margin-right: 2px;
      vertical-align: middle;
    }

    .hand-tiles {
      margin-top: 4px;
      margin-bottom: 4px;
    }

    .hand-tile {
      display: inline-block;
      margin-right: 2px;
    }
    .hand-tile-choice {
      cursor: pointer;
    }
    .hand-tile-choice:hover {
      outline: 2px solid #facc15;
    }

    .discard-choice {
      cursor: pointer;
    }
    .discard-choice:hover {
      outline: 2px solid #facc15;
    }

    .radio-group {
      margin-top: 8px;
      font-size: 0.85rem;
    }
    .radio-group label {
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>牌効率チェッカー（ツモ進行＆聴牌練習付き）</h1>

    <label for="handInput">
      手牌入力
      <div class="small-note">
        ・従来形式：<code>233445677m788p66z</code><br>
        ・省略形式：<code>123456 222 6789 1</code>（萬 / 筒 / 索 / 字牌 の順で半角スペース区切り）
      </div>
    </label>
    <input id="handInput" type="text" placeholder="例: 233445677m788p66z  または  123456 222 6789 1">
    <div id="countInfo" class="small-note"></div>

    <div class="checkbox-row">
      <label>
        <input type="checkbox" id="allowBack">
        シャンテン戻しを許可する（チェックしなければ「戻しなし」）
      </label>
    </div>

    <button id="calcBtn">計算する</button>
    <button id="tsumoStartBtn" style="margin-left:8px;">ツモ進行スタート</button>

    <div class="radio-group">
      練習牌セット：
      <label><input type="radio" name="practiceSet" value="all" checked> 通常（全牌）</label>
      <label><input type="radio" name="practiceSet" value="ps"> ピンズ＋ソーズのみ</label>
      <label><input type="radio" name="practiceSet" value="one"> 一色のみ（萬/筒/索のどれか）</label>
    </div>

    <div class="small-note">
      ・ツモ進行モード中は、<b>手牌の牌画像をタップ</b>して打牌します。<br>
      ・聴牌時は、<b>切る前は待ち牌を隠し</b>、切ったあとにその待ちと枚数を表示します。
    </div>

    <div id="error" class="error"></div>
    <div id="result" class="result"></div>
  </div>

  <script>
    // ==== ツモ進行用の状態 ====
    let tsumoMode = false;
    let wall = [];
    let wallPos = 0;
    let tsumoHand = null;
    let lastDrawId = null;

    // 聴牌選択スコア
    let tenpaiScoreSum = 0;
    let tenpaiHandsCount = 0;

    // ==== 牌ID → ラベル ====
    function tileLabel(id) {
      if (id >= 0 && id <= 8)  return (id + 1) + "m";
      if (id >= 9 && id <= 17) return (id - 8) + "p";
      if (id >= 18 && id <= 26) return (id - 17) + "s";
      const z = ["1z","2z","3z","4z","5z","6z","7z"];
      return z[id - 27];
    }

    // ==== 牌ID → 画像タグ ====
    function tileSpan(id) {
      const label = tileLabel(id); // "1m", "5p", "7s", "3z"
      const num = parseInt(label[0], 10);
      const suit = label[1];
      let fileName = "";

      if (suit === "m") {
        fileName = `麻雀牌-${num}萬.jpg`;
      } else if (suit === "p") {
        fileName = `麻雀牌-${num}筒.jpg`;
      } else if (suit === "s") {
        fileName = `麻雀牌-${num}索.jpg`;
      } else if (suit === "z") {
        const honorMap = {
          1: "東",
          2: "南",
          3: "西",
          4: "北",
          5: "白",
          6: "發",
          7: "中"
        };
        const honor = honorMap[num] || "東";
        fileName = `麻雀牌-${honor}.jpg`;
      }

      const src = `${fileName}`;  // ← tiles/ を消す
      return `<img src="${src}" alt="${label}" class="tile-img">`;

    }

    // ==== 手牌 → 牌画像列（クリック可/不可） ====
    function handToTiles(h, clickable = false) {
      let s = "";
      for (let id = 0; id < 34; id++) {
        for (let k = 0; k < h[id]; k++) {
          if (clickable) {
            s += `<span class="hand-tile hand-tile-choice" data-id="${id}">${tileSpan(id)}</span>`;
          } else {
            s += `<span class="hand-tile">${tileSpan(id)}</span>`;
          }
        }
      }
      return s || "(牌なし)";
    }

    // suit + num → ID
    function tileId(suit, num) {
      if (suit === "m") return num - 1;
      if (suit === "p") return 9 + num - 1;
      if (suit === "s") return 18 + num - 1;
      if (suit === "z") return 27 + num - 1;
      return -1;
    }

    // ==== 入力文字列 → 手牌配列 ====
    function parseHand(str) {
      const h = new Array(34).fill(0);
      if (!str) return h;
      const trimmed = str.trim();
      if (!trimmed) return h;

      const hasSuit = /[mpsz]/.test(trimmed);
      const hasSpace = /\s/.test(trimmed);

      // 省略形式（スペース区切り・mpszなし）
      if (!hasSuit && hasSpace) {
        const groups = trimmed.split(/\s+/).filter(g => g.length > 0);
        const suits = ["m", "p", "s", "z"];
        for (let gi = 0; gi < groups.length && gi < 4; gi++) {
          const g = groups[gi];
          const suit = suits[gi];
          for (const ch of g) {
            if (ch < "0" || ch > "9") continue;
            let num = parseInt(ch, 10);
            if (num === 0 && suit !== "z") num = 5;
            if (num < 1 || num > 9) continue;
            if (suit === "z" && num > 7) continue;
            const id = tileId(suit, num);
            if (id >= 0 && id < 34) h[id]++;
          }
        }
        return h;
      }

      // 従来形式（数字群 + m/p/s/z）
      let nums = [];
      for (const ch of trimmed) {
        if (ch >= "0" && ch <= "9") {
          nums.push(ch);
        } else if ("mpsz".includes(ch)) {
          const suit = ch;
          for (const n of nums) {
            let num = parseInt(n, 10);
            if (num === 0 && "mps".includes(suit)) num = 5;
            const id = tileId(suit, num);
            if (id >= 0 && id < 34) h[id]++;
          }
          nums = [];
        }
      }
      return h;
    }

    function handToString(h) {
      let s = "";
      function pushSuit(start, count, suit) {
        let nums = "";
        for (let i = 0; i < count; i++) {
          const id = start + i;
          for (let k = 0; k < h[id]; k++) {
            nums += String(i + 1);
          }
        }
        if (nums.length) s += nums + suit;
      }
      pushSuit(0, 9, "m");
      pushSuit(9, 9, "p");
      pushSuit(18, 9, "s");
      pushSuit(27, 7, "z");
      return s || "(牌なし)";
    }

    // ==== シャンテン計算 ====
    function shantenNormal(hand) {
      const h = hand.slice();
      let minSh = 8;

      function dfs(i, mentsu, taatsu, hasPair) {
        while (i < 34 && h[i] === 0) i++;
        if (i >= 34) {
          let t = taatsu;
          if (mentsu + t > 4) t = 4 - mentsu;
          const sh = 8 - mentsu * 2 - t - (hasPair ? 1 : 0);
          if (sh < minSh) minSh = sh;
          return;
        }

        if (!hasPair && h[i] >= 2) {
          h[i] -= 2;
          dfs(i, mentsu, taatsu, true);
          h[i] += 2;
        }

        if (h[i] >= 2) {
          h[i] -= 2;
          dfs(i, mentsu, taatsu + 1, hasPair);
          h[i] += 2;
        }

        if (h[i] >= 3) {
          h[i] -= 3;
          dfs(i, mentsu + 1, taatsu, hasPair);
          h[i] += 3;
        }

        if (i < 27 && i % 9 <= 6) {
          if (h[i] > 0 && h[i + 1] > 0 && h[i + 2] > 0) {
            h[i]--; h[i + 1]--; h[i + 2]--;
            dfs(i, mentsu + 1, taatsu, hasPair);
            h[i]++; h[i + 1]++; h[i + 2]++;
          }
          if (h[i] > 0 && h[i + 1] > 0) {
            h[i]--; h[i + 1]--;
            dfs(i, mentsu, taatsu + 1, hasPair);
            h[i]++; h[i + 1]++;
          }
          if (h[i] > 0 && h[i + 2] > 0) {
            h[i]--; h[i + 2]--;
            dfs(i, mentsu, taatsu + 1, hasPair);
            h[i]++; h[i + 2]++;
          }
        }

        dfs(i + 1, mentsu, taatsu, hasPair);
      }

      dfs(0, 0, 0, false);
      return minSh;
    }

    function shantenChiitoi(hand) {
      let nPairs = 0;
      let nUnique = 0;
      for (const c of hand) {
        if (c >= 2) nPairs++;
        if (c > 0) nUnique++;
      }
      let sh = 6 - nPairs + Math.max(0, 7 - nUnique);
      if (sh < -1) sh = -1;
      return sh;
    }

    function shantenKokushi(hand) {
      const yaochu = [0,8,9,17,18,26,27,28,29,30,31,32,33];
      let nUni = 0;
      let hasPair = false;
      for (const id of yaochu) {
        if (hand[id] > 0) {
          nUni++;
          if (hand[id] >= 2) hasPair = true;
        }
      }
      const sh = 13 - nUni - (hasPair ? 1 : 0);
      return sh;
    }

    function shantenAll(hand) {
      const sN = shantenNormal(hand);
      const sC = shantenChiitoi(hand);
      const sK = shantenKokushi(hand);
      return Math.min(sN, sC, sK);
    }

    // ==== 打牌ごとの受け入れ計算（1シャンテン以上用） ====
    function calcForDiscard(origHand, discId, allowBack) {
      if (origHand[discId] === 0) return null;

      const beforeSh = shantenAll(origHand);
      const h13 = origHand.slice();
      h13[discId]--;

      const afterDiscardSh = shantenAll(h13);
      if (!allowBack && afterDiscardSh > beforeSh) {
        return null;
      }

      const improvingTypes = [];
      let totalUkeire = 0;

      for (let t = 0; t < 34; t++) {
        if (h13[t] >= 4) continue;
        const h14 = h13.slice();
        h14[t]++;

        let bestSh = Infinity;
        for (let d = 0; d < 34; d++) {
          if (h14[d] === 0) continue;
          h14[d]--;
          const s = shantenAll(h14);
          h14[d]++;
          if (s < bestSh) bestSh = s;
        }

        if (bestSh < afterDiscardSh) {
          improvingTypes.push(t);
          totalUkeire += (4 - h13[t]);
        }
      }

      return {
        discardId: discId,
        afterDiscardSh,
        improvingTypes,
        totalUkeire
      };
    }

    function calcAllDiscards(hand, allowBack) {
      const results = [];
      for (let id = 0; id < 34; id++) {
        if (hand[id] === 0) continue;
        const r = calcForDiscard(hand, id, allowBack);
        if (r && r.improvingTypes.length > 0) {
          results.push(r);
        }
      }
      if (results.length === 0) return [];
      results.sort((a, b) => {
        if (a.afterDiscardSh !== b.afterDiscardSh) {
          return a.afterDiscardSh - b.afterDiscardSh;
        }
        return b.totalUkeire - a.totalUkeire;
      });
      return results.slice(0, 5);
    }

    // ==== 聴牌用：ある打牌の待ちを計算 ====
    function calcWaitForDiscard(origHand, discId, allowBack) {
      if (origHand[discId] === 0) return null;

      const beforeSh = shantenAll(origHand);
      if (beforeSh !== 0) return null; // 聴牌のとき専用

      const h13 = origHand.slice();
      h13[discId]--;

      const afterDiscardSh = shantenAll(h13);
      if (!allowBack && afterDiscardSh > beforeSh) {
        // ノーテンに戻す打牌は除外（シャンテン戻し禁止のとき）
        return null;
      }

      const waitTypes = [];
      let totalWait = 0;

      for (let t = 0; t < 34; t++) {
        if (h13[t] >= 4) continue;
        const h14 = h13.slice();
        h14[t]++;
        const sh = shantenAll(h14);
        if (sh <= -1) { // 和了形になる牌
          waitTypes.push(t);
          totalWait += (4 - h13[t]);
        }
      }

      return {
        discardId: discId,
        waitTypes,
        totalWait,
        afterDiscardSh
      };
    }

    function calcWaitAllDiscards(hand, allowBack) {
      const results = [];
      for (let id = 0; id < 34; id++) {
        if (hand[id] === 0) continue;
        const r = calcWaitForDiscard(hand, id, allowBack);
        if (r && r.waitTypes.length > 0) {
          results.push(r);
        }
      }
      if (results.length === 0) return [];
      results.sort((a, b) => b.totalWait - a.totalWait);
      return results.slice(0, 5);
    }

    // ==== 練習モード選択 ====
    function getPracticeMode() {
      const els = document.querySelectorAll('input[name="practiceSet"]');
      for (const el of els) {
        if (el.checked) return el.value;
      }
      return "all";
    }

    // ==== 山生成＆ツモ ====
    function makeShuffledWall() {
      const mode = getPracticeMode();
      const deck = [];

      if (mode === "ps") {
        for (let id = 9; id <= 26; id++) {
          for (let k = 0; k < 4; k++) deck.push(id);
        }
      } else if (mode === "one") {
        const suits = [0, 1, 2]; // m, p, s
        const s = suits[Math.floor(Math.random() * suits.length)];
        const base = s * 9;
        for (let id = base; id < base + 9; id++) {
          for (let k = 0; k < 4; k++) deck.push(id);
        }
      } else {
        for (let id = 0; id < 34; id++) {
          for (let k = 0; k < 4; k++) deck.push(id);
        }
      }

      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
      return deck;
    }

    function tsumoOne() {
      if (!tsumoMode || wallPos >= wall.length) return null;
      const id = wall[wallPos++];
      tsumoHand[id]++;
      return id;
    }

    // ==== 入力中の枚数表示 ====
    function updateCountInfo() {
      const val = document.getElementById("handInput").value;
      const infoEl = document.getElementById("countInfo");
      if (!val.trim()) {
        infoEl.textContent = "";
        return;
      }
      const h = parseHand(val);
      const c = h.reduce((a,b) => a + b, 0);
      let msg = `現在 ${c} 枚`;
      if (c < 14) {
        msg += `（あと ${14 - c} 枚で14枚）`;
      } else if (c > 14) {
        msg += `（${c - 14} 枚多いです）`;
      } else {
        msg += `（ちょうど14枚です）`;
      }
      infoEl.textContent = msg;
    }

    document.getElementById("handInput").addEventListener("input", updateCountInfo);

    // ==== 解析＋表示 ====
    function renderAnalysisFromHand(hand, extraMessageHtml = "", enableClick = false) {
      const errEl = document.getElementById("error");
      const resEl = document.getElementById("result");
      const allowBack = document.getElementById("allowBack").checked;

      errEl.textContent = "";
      resEl.textContent = "";

      const tileCount = hand.reduce((a,b) => a + b, 0);
      if (tileCount === 0) {
        errEl.textContent = "手牌が読み取れませんでした。";
        return;
      }

      const originalSh = shantenAll(hand);
      const originalStr = handToString(hand);
      const clickableHand = enableClick && tsumoMode;
      const handTilesHtml = handToTiles(hand, clickableHand);

      let warn = "";
      if (tileCount !== 14) {
        warn = `（現在 ${tileCount} 枚。14枚想定ですが、そのまま計算します）`;
      }

      // --- 13枚：ツモ有効牌一覧 ---
      if (!tsumoMode && tileCount === 13) {
        let html = "";
        html += `<div>入力手牌：</div>`;
        html += `<div class="hand-tiles">${handTilesHtml}</div>`;
        html += `<div class="small-note">
          テキスト表記：<code>${originalStr}</code>　枚数：${tileCount}枚
        </div>`;
        html += `<div>現在の最小シャンテン：<strong>${originalSh}</strong></div>`;
        html += `<div class="small-note">※ この13枚に対して、ツモでシャンテンが改善する有効牌のみを表示します。</div>`;
        if (extraMessageHtml) {
          html += `<div class="small-note" style="margin-top:4px;">${extraMessageHtml}</div>`;
        }

        const effective = [];
        let totalUkeire = 0;
        for (let t = 0; t < 34; t++) {
          if (hand[t] >= 4) continue;
          const h14 = hand.slice();
          h14[t]++;
          const shAfter = shantenAll(h14);
          if (shAfter < originalSh) {
            const remain = 4 - hand[t];
            totalUkeire += remain;
            effective.push({ id: t, remain, shAfter });
          }
        }

        if (effective.length === 0) {
          html += `<div style="margin-top:8px;">シャンテンがこれ以上良くなるツモはありません。</div>`;
          resEl.innerHTML = html;
          return;
        }

        effective.sort((a, b) => b.remain - a.remain);

        html += `<div style="margin-top:8px;">この13枚に対するツモ有効牌一覧：</div>`;
        html += `<div class="small-note">合計受け入れ枚数：${totalUkeire}</div>`;
        html += `<table>
          <thead>
            <tr>
              <th>有効牌</th>
              <th>残り枚数</th>
            </tr>
          </thead>
          <tbody>`;

        for (const e of effective) {
          html += `<tr>
            <td>${tileSpan(e.id)}</td>
            <td>${e.remain}</td>
          </tr>`;
        }

        html += `</tbody></table>`;
        resEl.innerHTML = html;
        return;
      }

      // --- 14枚以上共通ヘッダ ---
      let html = "";
      html += `<div>入力手牌：</div>`;
      html += `<div class="hand-tiles">${handTilesHtml}</div>`;
      html += `<div class="small-note">
        テキスト表記：<code>${originalStr}</code>　枚数：${tileCount}枚 ${warn}
      </div>`;
      html += `<div>元の最小シャンテン：<strong>${originalSh}</strong></div>`;
      html += `<div class="small-note">※ 通常手・七対子・国士のうち最も良いシャンテンを使用</div>`;

      if (extraMessageHtml) {
        html += `<div class="small-note" style="margin-top:4px;">${extraMessageHtml}</div>`;
      }

      // --- 聴牌（0シャンテン）：待ち牌モード ---
      if (originalSh === 0) {
        const waitResults = calcWaitAllDiscards(hand, allowBack);

        if (waitResults.length === 0) {
          html += `<div style="margin-top:8px;">待ち牌情報を計算できませんでした。</div>`;
          resEl.innerHTML = html;
          return;
        }

        const hideAnswer = tsumoMode; // ツモ進行中は切るまで待ちを隠す

        html += `<table>
          <thead>
            <tr>
              <th>打牌</th>
              <th>打牌後シャンテン</th>
              <th>待ち枚数</th>
              <th>待ち牌</th>
            </tr>
          </thead>
          <tbody>`;

        for (const r of waitResults) {
          const discardCell = (enableClick && tsumoMode)
            ? `<span class="discard-choice" data-id="${r.discardId}">${tileSpan(r.discardId)}</span>`
            : tileSpan(r.discardId);

          const countCell = hideAnswer ? "？" : r.totalWait;
          const kindsCell = hideAnswer
            ? "（切ったあとに表示）"
            : r.waitTypes.map(tileSpan).join("");

          html += `<tr>
            <td>${discardCell}</td>
            <td>${r.afterDiscardSh}</td>
            <td>${countCell}</td>
            <td>${kindsCell}</td>
          </tr>`;
        }

        html += `</tbody></table>`;
        resEl.innerHTML = html;

        if (enableClick && tsumoMode) {
          document.querySelectorAll(".discard-choice").forEach(el => {
            el.addEventListener("click", () => {
              const id = parseInt(el.getAttribute("data-id"), 10);
              handleDiscardClick(id);
            });
          });
          document.querySelectorAll(".hand-tile-choice").forEach(el => {
            el.addEventListener("click", () => {
              const id = parseInt(el.getAttribute("data-id"), 10);
              handleDiscardClick(id);
            });
          });
        }
        return;
      }

      // --- それ以外（1シャンテン以上）：従来通り 有効牌 ---
      const discResults = calcAllDiscards(hand, allowBack);

      if (discResults.length === 0) {
        html += `<div style="margin-top:8px;">有効な打牌候補が見つかりませんでした。</div>`;
        resEl.innerHTML = html;
        return;
      }

      html += `<table>
        <thead>
          <tr>
            <th>打牌</th>
            <th>打牌後シャンテン</th>
            <th>受け入れ枚数</th>
            <th>受け入れ牌の種類</th>
          </tr>
        </thead>
        <tbody>`;

      for (const r of discResults) {
        const discardCell = (enableClick && tsumoMode)
          ? `<span class="discard-choice" data-id="${r.discardId}">${tileSpan(r.discardId)}</span>`
          : tileSpan(r.discardId);
        const kindsHtml = r.improvingTypes.map(tileSpan).join("");
        html += `<tr>
          <td>${discardCell}</td>
          <td>${r.afterDiscardSh}</td>
          <td>${r.totalUkeire}</td>
          <td>${kindsHtml}</td>
        </tr>`;
      }

      html += `</tbody></table>`;
      resEl.innerHTML = html;

      if (enableClick && tsumoMode) {
        document.querySelectorAll(".discard-choice").forEach(el => {
          el.addEventListener("click", () => {
            const id = parseInt(el.getAttribute("data-id"), 10);
            handleDiscardClick(id);
          });
        });
        document.querySelectorAll(".hand-tile-choice").forEach(el => {
          el.addEventListener("click", () => {
            const id = parseInt(el.getAttribute("data-id"), 10);
            handleDiscardClick(id);
          });
        });
      }
    }

    // ==== 通常「計算する」 ====
    document.getElementById("calcBtn").addEventListener("click", () => {
      tsumoMode = false;
      const input = document.getElementById("handInput").value;
      const hand = parseHand(input);
      renderAnalysisFromHand(hand);
    });

    // ==== ツモ進行スタート ====
    document.getElementById("tsumoStartBtn").addEventListener("click", () => {
      // スコアリセット
      tenpaiScoreSum = 0;
      tenpaiHandsCount = 0;

      wall = makeShuffledWall();
      wallPos = 0;
      tsumoHand = new Array(34).fill(0);
      for (let i = 0; i < 13 && wallPos < wall.length; i++) {
        tsumoHand[wall[wallPos++]]++;
      }
      tsumoMode = true;

      const firstDraw = tsumoOne();
      lastDrawId = firstDraw;

      document.getElementById("handInput").value = handToString(tsumoHand);
      updateCountInfo();

      const drawMsg = firstDraw !== null
        ? `ツモ進行モード開始。今回のツモ：${tileSpan(firstDraw)}（練習セット: ${getPracticeMode()}）`
        : `山がありません。`;

      renderAnalysisFromHand(tsumoHand, drawMsg, true);
    });


    function handleDiscardClick(discId) {
  if (!tsumoMode || !tsumoHand) return;
  if (tsumoHand[discId] === 0) return;

  const errEl = document.getElementById("error");
  const allowBack = document.getElementById("allowBack").checked;
  errEl.textContent = "";

  // 今の手牌をコピー（＝直前の手牌）
  const beforeHand = tsumoHand.slice();
  const beforeSh = shantenAll(beforeHand);

  // すでに和了形なら終了
  if (beforeSh <= -1) {
    errEl.textContent = "すでに和了形です。ツモ進行モードを終了します。";
    tsumoMode = false;

    const resEl = document.getElementById("result");
    if (tenpaiHandsCount > 0) {
      resEl.innerHTML += `<div class="small-note" style="margin-top:8px;">
        聴牌局での選択スコア：合計差 ${tenpaiScoreSum} 枚（局数 ${tenpaiHandsCount}）
      </div>`;
    }
    return;
  }

  // --- 直前の手牌について「正解表」を作る ---
  let extraInfoHtml = "";

  if (beforeSh === 0) {
    // ☆聴牌の場合：待ち枚数で評価
    const answers = calcWaitAllDiscards(beforeHand, allowBack);
    if (answers.length > 0) {
      const bestWait = answers[0].totalWait;  // 一番待ちが多い打牌の枚数

      // スコア計算（ベストとの差）
      let myWait = 0;
      for (const r of answers) {
        if (r.discardId === discId) {
          myWait = r.totalWait;
          break;
        }
      }
      if (bestWait > 0) {
        const diff = Math.max(0, bestWait - myWait);
        tenpaiScoreSum += diff;
        tenpaiHandsCount += 1;
      }

      // 正解表をHTML化
      let table = `<div class="small-note" style="margin-top:8px;">
        直前の手牌（聴牌）の解答：
      </div>`;
      table += `<table>
        <thead>
          <tr>
            <th>打牌</th>
            <th>待ち枚数</th>
            <th>待ち牌</th>
            <th>評価</th>
          </tr>
        </thead>
        <tbody>`;

      for (const r of answers) {
        const isBest = (r.totalWait === bestWait);
        const isMine = (r.discardId === discId);
        const waitsHtml = r.waitTypes.map(tileSpan).join("");
        let tag = "";
        if (isBest && isMine) tag = "◎ ベスト＆あなたの選択";
        else if (isBest) tag = "○ ベスト";
        else if (isMine) tag = "▲ あなたの選択";

        table += `<tr>
          <td>${tileSpan(r.discardId)}</td>
          <td>${r.totalWait}</td>
          <td>${waitsHtml}</td>
          <td>${tag}</td>
        </tr>`;
      }

      table += `</tbody></table>`;
      extraInfoHtml = table;
    }
  } else {
    // ☆まだシャンテンが残っている場合：受け入れ枚数で評価
    const answers = calcAllDiscards(beforeHand, allowBack);
    if (answers.length > 0) {
      const bestUkeire = answers[0].totalUkeire;

      // 正解表（受け入れ版）
      let table = `<div class="small-note" style="margin-top:8px;">
        直前の手牌の解答（受け入れ枚数ベース）：
      </div>`;
      table += `<table>
        <thead>
          <tr>
            <th>打牌</th>
            <th>打牌後シャンテン</th>
            <th>受け入れ枚数</th>
            <th>受け入れ牌</th>
            <th>評価</th>
          </tr>
        </thead>
        <tbody>`;

      for (const r of answers) {
        const isBest = (r.totalUkeire === bestUkeire &&
                        r.afterDiscardSh === answers[0].afterDiscardSh);
        const isMine = (r.discardId === discId);
        const kindsHtml = r.improvingTypes.map(tileSpan).join("");
        let tag = "";
        if (isBest && isMine) tag = "◎ ベスト＆あなたの選択";
        else if (isBest) tag = "○ ベスト";
        else if (isMine) tag = "▲ あなたの選択";

        table += `<tr>
          <td>${tileSpan(r.discardId)}</td>
          <td>${r.afterDiscardSh}</td>
          <td>${r.totalUkeire}</td>
          <td>${kindsHtml}</td>
          <td>${tag}</td>
        </tr>`;
      }

      table += `</tbody></table>`;
      extraInfoHtml = table;
    }
  }

  // --- 実際にその牌を捨てる ---
  tsumoHand[discId]--;

  // 次ツモ（ツモ進行モードなので1枚引く）
  const nextDraw = tsumoOne();
  lastDrawId = nextDraw;

  document.getElementById("handInput").value = handToString(tsumoHand);
  updateCountInfo();

  if (nextDraw === null) {
    let msg = "山が尽きました。ツモ進行モードを終了します。";
    if (extraInfoHtml) {
      msg += "<br>" + extraInfoHtml;
    }
    renderAnalysisFromHand(tsumoHand, msg, false);
    tsumoMode = false;

    const resEl = document.getElementById("result");
    if (tenpaiHandsCount > 0) {
      resEl.innerHTML += `<div class="small-note" style="margin-top:8px;">
        聴牌局での選択スコア：合計差 ${tenpaiScoreSum} 枚（局数 ${tenpaiHandsCount}）
      </div>`;
    }
    return;
  }

  let msg = `あなたの打牌：${tileSpan(discId)} ／ 今回のツモ：${tileSpan(nextDraw)}`;
  if (extraInfoHtml) {
    msg += "<br>" + extraInfoHtml;
  }
  renderAnalysisFromHand(tsumoHand, msg, true);
}
  </script>
</body>
</html>


