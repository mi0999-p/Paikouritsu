<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>牌効率チェッカー（ツモ進行モード付き）</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      margin: 0;
      padding: 16px;
      background: #111;
      color: #eee;
    }
    h1 {
      font-size: 1.4rem;
      margin-bottom: 0.5rem;
    }
    .card {
      background: #1b1b1b;
      border-radius: 12px;
      padding: 16px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      max-width: 900px;
      margin: 0 auto;
    }
    label {
      font-size: 0.9rem;
    }
    input[type="text"] {
      width: 100%;
      padding: 8px 10px;
      margin-top: 4px;
      border-radius: 6px;
      border: 1px solid #444;
      background: #111;
      color: #eee;
      box-sizing: border-box;
      font-size: 0.95rem;
      font-family: "SF Mono", Menlo, monospace;
    }
    button {
      margin-top: 10px;
      padding: 8px 14px;
      border-radius: 999px;
      border: none;
      background: #3b82f6;
      color: white;
      font-size: 0.9rem;
      cursor: pointer;
    }
    button:hover {
      background: #2563eb;
    }
    .checkbox-row {
      margin-top: 8px;
      font-size: 0.9rem;
    }
    .error {
      margin-top: 8px;
      color: #f97373;
      font-size: 0.85rem;
    }
    .result {
      margin-top: 16px;
      font-size: 0.9rem;
    }
    table {
      width: 100%;
      border-collapse: collapse;
      margin-top: 8px;
      font-size: 0.85rem;
    }
    th, td {
      padding: 6px 4px;
      border-bottom: 1px solid #333;
      text-align: left;
      vertical-align: top;
    }
    th {
      border-bottom: 1px solid #555;
      color: #ddd;
    }
    .small-note {
      font-size: 0.8rem;
      color: #aaa;
      margin-top: 4px;
    }
    #countInfo {
      margin-top: 4px;
    }

    /* 牌っぽい表示 */
    .tile {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      min-width: 20px;
      height: 28px;
      padding: 2px 4px;
      margin: 1px 2px 1px 0;
      border-radius: 4px;
      border: 1px solid #555;
      background: #f9fafb;
      color: #111;
      font-size: 0.8rem;
      box-shadow: 0 1px 2px rgba(0,0,0,0.5);
    }
    .tile-m { border-color: #f97373; }
    .tile-p { border-color: #60a5fa; }
    .tile-s { border-color: #4ade80; }
    .tile-z { border-color: #e5e7eb; }
    .hand-tiles {
      margin-top: 4px;
      margin-bottom: 4px;
    }
    .discard-choice {
      cursor: pointer;
    }
    .discard-choice:hover {
      outline: 2px solid #facc15;
    }

    .radio-group {
      margin-top: 8px;
      font-size: 0.85rem;
    }
    .radio-group label {
      margin-right: 8px;
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>牌効率チェッカー（シャンテン戻しなし・ツモ進行モード付き）</h1>

    <label for="handInput">
      手牌入力
      <div class="small-note">
        ・従来形式：<code>233445677m788p66z</code><br>
        ・省略形式：<code>123456 222 6789 1</code>（萬 / 筒 / 索 / 字牌 の順で半角スペース区切り）
      </div>
    </label>
    <input id="handInput" type="text" placeholder="例: 233445677m788p66z  または  123456 222 6789 1">
    <div id="countInfo" class="small-note"></div>

    <div class="checkbox-row">
      <label>
        <input type="checkbox" id="allowBack">
        シャンテン戻しを許可する（チェックしなければ「戻しなし」）
      </label>
    </div>

    <button id="calcBtn">計算する</button>
    <button id="tsumoStartBtn" style="margin-left:8px;">ツモ進行スタート</button>

    <div class="radio-group">
      練習牌セット：
      <label><input type="radio" name="practiceSet" value="all" checked> 通常（全牌）</label>
      <label><input type="radio" name="practiceSet" value="ps"> ピンズ＋ソーズのみ</label>
      <label><input type="radio" name="practiceSet" value="one"> 一色のみ（萬/筒/索のどれか）</label>
    </div>

    <div class="small-note">
      ※ ツモ進行モード中は、表の「打牌」欄の牌をクリックすると、その牌を切って次ツモに進みます。
    </div>

    <div id="error" class="error"></div>
    <div id="result" class="result"></div>
  </div>

  <script>
    // ==== ツモ進行用の状態 ====
    let tsumoMode = false;
    let wall = [];         // 山
    let wallPos = 0;       // 次にツモる位置
    let tsumoHand = null;  // 進行中の手牌
    let lastDrawId = null; // 直前のツモ牌

    // ==== 牌ID → ラベル/見た目 ====
    function tileLabel(id) {
      if (id >= 0 && id <= 8)  return (id + 1) + "m";
      if (id >= 9 && id <= 17) return (id - 8) + "p";
      if (id >= 18 && id <= 26) return (id - 17) + "s";
      const z = ["1z","2z","3z","4z","5z","6z","7z"];
      return z[id - 27];
    }

    function tileSpan(id) {
      let num, suit, cls;
      if (id >= 0 && id <= 8) {
        num = id + 1; suit = "m"; cls = "tile-m";
      } else if (id >= 9 && id <= 17) {
        num = id - 8; suit = "p"; cls = "tile-p";
      } else if (id >= 18 && id <= 26) {
        num = id - 17; suit = "s"; cls = "tile-s";
      } else {
        num = id - 26; suit = "z"; cls = "tile-z";
      }
      let text;
      if (suit === "z") {
        const zs = ["東","南","西","北","白","發","中"];
        text = zs[num - 1] || "?";
      } else {
        text = String(num);
      }
      return `<span class="tile ${cls}">${text}</span>`;
    }

    function handToTiles(h) {
      let s = "";
      for (let id = 0; id < 34; id++) {
        for (let k = 0; k < h[id]; k++) {
          s += tileSpan(id);
        }
      }
      return s || "(牌なし)";
    }

    // suit + num → ID
    function tileId(suit, num) {
      if (suit === "m") return num - 1;
      if (suit === "p") return 9 + num - 1;
      if (suit === "s") return 18 + num - 1;
      if (suit === "z") return 27 + num - 1;
      return -1;
    }

    // ==== 入力文字列 → 手牌配列 ====
    function parseHand(str) {
      const h = new Array(34).fill(0);
      if (!str) return h;
      const trimmed = str.trim();
      if (!trimmed) return h;

      const hasSuit = /[mpsz]/.test(trimmed);
      const hasSpace = /\s/.test(trimmed);

      // 省略形式（スペース区切り・mpszなし）
      if (!hasSuit && hasSpace) {
        const groups = trimmed.split(/\s+/).filter(g => g.length > 0);
        const suits = ["m", "p", "s", "z"];
        for (let gi = 0; gi < groups.length && gi < 4; gi++) {
          const g = groups[gi];
          const suit = suits[gi];
          for (const ch of g) {
            if (ch < "0" || ch > "9") continue;
            let num = parseInt(ch, 10);
            if (num === 0 && suit !== "z") num = 5;
            if (num < 1 || num > 9) continue;
            if (suit === "z" && num > 7) continue;
            const id = tileId(suit, num);
            if (id >= 0 && id < 34) h[id]++;
          }
        }
        return h;
      }

      // 従来形式（数字群 + m/p/s/z）
      let nums = [];
      for (const ch of trimmed) {
        if (ch >= "0" && ch <= "9") {
          nums.push(ch);
        } else if ("mpsz".includes(ch)) {
          const suit = ch;
          for (const n of nums) {
            let num = parseInt(n, 10);
            if (num === 0 && "mps".includes(suit)) num = 5;
            const id = tileId(suit, num);
            if (id >= 0 && id < 34) h[id]++;
          }
          nums = [];
        } else {
          // その他（スペースとか）は無視
        }
      }
      return h;
    }

    function handToString(h) {
      let s = "";
      function pushSuit(start, count, suit) {
        let nums = "";
        for (let i = 0; i < count; i++) {
          const id = start + i;
          for (let k = 0; k < h[id]; k++) {
            nums += String(i + 1);
          }
        }
        if (nums.length) s += nums + suit;
      }
      pushSuit(0, 9, "m");
      pushSuit(9, 9, "p");
      pushSuit(18, 9, "s");
      pushSuit(27, 7, "z");
      return s || "(牌なし)";
    }

    // ==== シャンテン計算 ====
    function shantenNormal(hand) {
      const h = hand.slice();
      let minSh = 8;

      function dfs(i, mentsu, taatsu, hasPair) {
        while (i < 34 && h[i] === 0) i++;
        if (i >= 34) {
          let t = taatsu;
          if (mentsu + t > 4) t = 4 - mentsu;
          const sh = 8 - mentsu * 2 - t - (hasPair ? 1 : 0);
          if (sh < minSh) minSh = sh;
          return;
        }

        // 対子 → 雀頭
        if (!hasPair && h[i] >= 2) {
          h[i] -= 2;
          dfs(i, mentsu, taatsu, true);
          h[i] += 2;
        }

        // 対子 → ターツ（シャボ候補）
        if (h[i] >= 2) {
          h[i] -= 2;
          dfs(i, mentsu, taatsu + 1, hasPair);
          h[i] += 2;
        }

        // 刻子
        if (h[i] >= 3) {
          h[i] -= 3;
          dfs(i, mentsu + 1, taatsu, hasPair);
          h[i] += 3;
        }

        // 順子・ターツ（数牌のみ）
        if (i < 27 && i % 9 <= 6) {
          // 順子
          if (h[i] > 0 && h[i + 1] > 0 && h[i + 2] > 0) {
            h[i]--; h[i + 1]--; h[i + 2]--;
            dfs(i, mentsu + 1, taatsu, hasPair);
            h[i]++; h[i + 1]++; h[i + 2]++;
          }
          // 両面
          if (h[i] > 0 && h[i + 1] > 0) {
            h[i]--; h[i + 1]--;
            dfs(i, mentsu, taatsu + 1, hasPair);
            h[i]++; h[i + 1]++;
          }
          // カンチャン
          if (h[i] > 0 && h[i + 2] > 0) {
            h[i]--; h[i + 2]--;
            dfs(i, mentsu, taatsu + 1, hasPair);
            h[i]++; h[i + 2]++;
          }
        }

        // この牌を使わない
        dfs(i + 1, mentsu, taatsu, hasPair);
      }

      dfs(0, 0, 0, false);
      return minSh;
    }

    function shantenChiitoi(hand) {
      let nPairs = 0;
      let nUnique = 0;
      for (const c of hand) {
        if (c >= 2) nPairs++;
        if (c > 0) nUnique++;
      }
      let sh = 6 - nPairs + Math.max(0, 7 - nUnique);
      if (sh < -1) sh = -1;
      return sh;
    }

    function shantenKokushi(hand) {
      const yaochu = [0,8,9,17,18,26,27,28,29,30,31,32,33];
      let nUni = 0;
      let hasPair = false;
      for (const id of yaochu) {
        if (hand[id] > 0) {
          nUni++;
          if (hand[id] >= 2) hasPair = true;
        }
      }
      const sh = 13 - nUni - (hasPair ? 1 : 0);
      return sh;
    }

    function shantenAll(hand) {
      const sN = shantenNormal(hand);
      const sC = shantenChiitoi(hand);
      const sK = shantenKokushi(hand);
      return Math.min(sN, sC, sK);
    }

    // ==== 打牌ごとの受け入れ計算 ====
    function calcForDiscard(origHand, discId, allowBack) {
      if (origHand[discId] === 0) return null;

      const beforeSh = shantenAll(origHand);

      const h13 = origHand.slice();
      h13[discId]--;

      const afterDiscardSh = shantenAll(h13);
      if (!allowBack && afterDiscardSh > beforeSh) {
        return null;
      }

      const improvingTypes = [];
      let totalUkeire = 0;

      for (let t = 0; t < 34; t++) {
        if (h13[t] >= 4) continue;

        const h14 = h13.slice();
        h14[t]++;

        let bestSh = Infinity;
        for (let d = 0; d < 34; d++) {
          if (h14[d] === 0) continue;
          h14[d]--;
          const s = shantenAll(h14);
          h14[d]++;
          if (s < bestSh) bestSh = s;
        }

        if (bestSh < afterDiscardSh) {
          improvingTypes.push(t);
          totalUkeire += (4 - h13[t]);
        }
      }

      return {
        discardId: discId,
        afterDiscardSh,
        improvingTypes,
        totalUkeire
      };
    }

    function calcAllDiscards(hand, allowBack) {
      const results = [];
      for (let id = 0; id < 34; id++) {
        if (hand[id] === 0) continue;
        const r = calcForDiscard(hand, id, allowBack);
        if (r && r.improvingTypes.length > 0) {
          results.push(r);
        }
      }
      if (results.length === 0) return [];
      results.sort((a, b) => {
        if (a.afterDiscardSh !== b.afterDiscardSh) {
          return a.afterDiscardSh - b.afterDiscardSh;
        }
        return b.totalUkeire - a.totalUkeire;
      });
      return results.slice(0, 5);
    }

    // ==== 練習モード選択 ====
    function getPracticeMode() {
      const els = document.querySelectorAll('input[name="practiceSet"]');
      for (const el of els) {
        if (el.checked) return el.value;
      }
      return "all";
    }

    // ==== 山生成＆ツモ ====
    function makeShuffledWall() {
      const mode = getPracticeMode();
      const deck = [];

      if (mode === "ps") {
        // ピンズ(9〜17)＋ソーズ(18〜26) だけ
        for (let id = 9; id <= 26; id++) {
          for (let k = 0; k < 4; k++) deck.push(id);
        }
      } else if (mode === "one") {
        // 一色のみ（萬/筒/索のどれかをランダムに選ぶ）
        const suits = [0, 1, 2]; // 0: m, 1: p, 2: s
        const s = suits[Math.floor(Math.random() * suits.length)];
        const base = s * 9; // 0, 9, 18 のどれか
        for (let id = base; id < base + 9; id++) {
          for (let k = 0; k < 4; k++) deck.push(id);
        }
      } else {
        // 通常（全牌）
        for (let id = 0; id < 34; id++) {
          for (let k = 0; k < 4; k++) deck.push(id);
        }
      }

      // シャッフル
      for (let i = deck.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [deck[i], deck[j]] = [deck[j], deck[i]];
      }
      return deck;
    }

    function tsumoOne() {
      if (!tsumoMode || wallPos >= wall.length) return null;
      const id = wall[wallPos++];
      tsumoHand[id]++;
      return id;
    }

    // ==== 入力中の枚数表示 ====
    function updateCountInfo() {
      const val = document.getElementById("handInput").value;
      const infoEl = document.getElementById("countInfo");
      if (!val.trim()) {
        infoEl.textContent = "";
        return;
      }
      const h = parseHand(val);
      const c = h.reduce((a,b) => a + b, 0);
      let msg = `現在 ${c} 枚`;
      if (c < 14) {
        msg += `（あと ${14 - c} 枚で14枚）`;
      } else if (c > 14) {
        msg += `（${c - 14} 枚多いです）`;
      } else {
        msg += `（ちょうど14枚です）`;
      }
      infoEl.textContent = msg;
    }

    document.getElementById("handInput").addEventListener("input", updateCountInfo);

    // ==== 解析＋表示（共通） ====    
    function renderAnalysisFromHand(hand, extraMessageHtml = "", enableClick = false) {
      const errEl = document.getElementById("error");
      const resEl = document.getElementById("result");
      const allowBack = document.getElementById("allowBack").checked;

      errEl.textContent = "";
      resEl.textContent = "";

      const tileCount = hand.reduce((a,b) => a + b, 0);
      if (tileCount === 0) {
        errEl.textContent = "手牌が読み取れませんでした。";
        return;
      }

      const originalSh = shantenAll(hand);
      const originalStr = handToString(hand);
      const handTilesHtml = handToTiles(hand);

      let warn = "";
      if (tileCount !== 14) {
        warn = `（現在 ${tileCount} 枚。14枚想定ですが、そのまま計算します）`;
      }

      // ---- シンプル13枚モード：有効牌のみ表示 ----
      if (!tsumoMode && tileCount === 13) {
        let html = "";
        html += `<div>入力手牌：</div>`;
        html += `<div class="hand-tiles">${handTilesHtml}</div>`;
        html += `<div class="small-note">
          テキスト表記：<code>${originalStr}</code>　枚数：${tileCount}枚
        </div>`;
        html += `<div>現在の最小シャンテン：<strong>${originalSh}</strong></div>`;
        html += `<div class="small-note">※ この13枚に対して、ツモでシャンテンが改善する有効牌のみを表示します。</div>`;
        if (extraMessageHtml) {
          html += `<div class="small-note" style="margin-top:4px;">${extraMessageHtml}</div>`;
        }

        const effective = [];
        let totalUkeire = 0;
        for (let t = 0; t < 34; t++) {
          if (hand[t] >= 4) continue;
          const h14 = hand.slice();
          h14[t]++;
          const shAfter = shantenAll(h14);
          if (shAfter < originalSh) {
            const remain = 4 - hand[t];
            totalUkeire += remain;
            effective.push({ id: t, remain, shAfter });
          }
        }

        if (effective.length === 0) {
          html += `<div style="margin-top:8px;">シャンテンがこれ以上良くなるツモはありません。</div>`;
          resEl.innerHTML = html;
          return;
        }

        effective.sort((a, b) => b.remain - a.remain);

        html += `<div style="margin-top:8px;">この13枚に対するツモ有効牌一覧：</div>`;
        html += `<div class="small-note">合計受け入れ枚数：${totalUkeire}</div>`;
        html += `<table>
          <thead>
            <tr>
              <th>有効牌</th>
              <th>残り枚数</th>
            </tr>
          </thead>
          <tbody>`;

        for (const e of effective) {
          html += `<tr>
            <td>${tileSpan(e.id)}</td>
            <td>${e.remain}</td>
          </tr>`;
        }

        html += `</tbody></table>`;
        resEl.innerHTML = html;
        return;
      }

      // ---- 14枚など：打牌候補トップ5 ----
      const discResults = calcAllDiscards(hand, allowBack);

      let html = "";
      html += `<div>入力手牌：</div>`;
      html += `<div class="hand-tiles">${handTilesHtml}</div>`;
      html += `<div class="small-note">
        テキスト表記：<code>${originalStr}</code>　枚数：${tileCount}枚 ${warn}
      </div>`;
      html += `<div>元の最小シャンテン：<strong>${originalSh}</strong></div>`;
      html += `<div class="small-note">※ 通常手・七対子・国士のうち最も良いシャンテンを使用</div>`;

      if (extraMessageHtml) {
        html += `<div class="small-note" style="margin-top:4px;">${extraMessageHtml}</div>`;
      }

      if (discResults.length === 0) {
        html += `<div style="margin-top:8px;">有効な打牌候補が見つかりませんでした。</div>`;
        resEl.innerHTML = html;
        return;
      }

      html += `<table>
        <thead>
          <tr>
            <th>打牌</th>
            <th>打牌後シャンテン</th>
            <th>受け入れ枚数</th>
            <th>受け入れ牌の種類</th>
          </tr>
        </thead>
        <tbody>`;

      for (const r of discResults) {
        const discardCell = (enableClick && tsumoMode)
          ? `<span class="discard-choice" data-id="${r.discardId}">${tileSpan(r.discardId)}</span>`
          : tileSpan(r.discardId);
        const kindsHtml = r.improvingTypes.map(tileSpan).join("");
        html += `<tr>
          <td>${discardCell}</td>
          <td>${r.afterDiscardSh}</td>
          <td>${r.totalUkeire}</td>
          <td>${kindsHtml}</td>
        </tr>`;
      }

      html += `</tbody></table>`;
      resEl.innerHTML = html;

      if (enableClick && tsumoMode) {
        document.querySelectorAll(".discard-choice").forEach(el => {
          el.addEventListener("click", () => {
            const id = parseInt(el.getAttribute("data-id"), 10);
            handleDiscardClick(id);
          });
        });
      }
    }

    // ==== 通常「計算する」ボタン ====
    document.getElementById("calcBtn").addEventListener("click", () => {
      tsumoMode = false; // 通常モードに戻す
      const input = document.getElementById("handInput").value;
      const hand = parseHand(input);
      renderAnalysisFromHand(hand);
    });

    // ==== ツモ進行スタート ====
    document.getElementById("tsumoStartBtn").addEventListener("click", () => {
      // 山＆手牌初期化
      wall = makeShuffledWall();
      wallPos = 0;
      tsumoHand = new Array(34).fill(0);
      for (let i = 0; i < 13 && wallPos < wall.length; i++) {
        tsumoHand[wall[wallPos++]]++;
      }
      tsumoMode = true;

      // 1枚ツモって14枚へ
      lastDrawId = tsumoOne();

      document.getElementById("handInput").value = handToString(tsumoHand);
      updateCountInfo();

      const drawMsg = lastDrawId !== null
        ? `ツモ進行モード開始。今回のツモ：${tileSpan(lastDrawId)}（練習セット: ${getPracticeMode()}）`
        : `山がありません。`;

      renderAnalysisFromHand(tsumoHand, drawMsg, true);
    });

    // ==== ツモモード中：打牌クリックで進行 ====
    function handleDiscardClick(discId) {
      if (!tsumoMode || !tsumoHand) return;
      if (tsumoHand[discId] === 0) return;

      const errEl = document.getElementById("error");
      errEl.textContent = "";

      // 和了していたら終了
      const sh = shantenAll(tsumoHand);
      if (sh <= -1) {
        errEl.textContent = "すでに和了形です。ツモ進行モードを終了します。";
        tsumoMode = false;
        return;
      }

      // 選んだ牌を捨てる
      tsumoHand[discId]--;

      // 次ツモ
      const nextDraw = tsumoOne();
      lastDrawId = nextDraw;

      document.getElementById("handInput").value = handToString(tsumoHand);
      updateCountInfo();

      if (nextDraw === null) {
        renderAnalysisFromHand(tsumoHand, "山が尽きました。ツモ進行モードを終了します。", false);
        tsumoMode = false;
        return;
      }

      const msg = `あなたの打牌：${tileSpan(discId)} ／ 今回のツモ：${tileSpan(nextDraw)}`;
      renderAnalysisFromHand(tsumoHand, msg, true);
    }
  </script>
</body>
</html>
